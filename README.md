# Fast-Country-Lookup-System
Designed and implemented a high-performance data lookup system using double hashing. Optimized search and retrieval operations for large datasets (country information) with constant-time average lookups, ensuring efficient data management similar to applications in databases or caching systems.

Class Definition
In Project 4, there are four classes are defined in the header file. 
First of all, the TimeSeries class manages individual time series data for each country by storing the identifiers: countryName, countryCode, seriesName, seriesCode, along with dynamically allocated arrays for years and data. Unlike Project 3 where country objects were stored in a fixed size array, the Node class now maintains these objects in a hash table of fixed size 512 using double hashing for efficient O(1) lookups, in the public of the TimeSeries class, there are also the getter functions and setter functions, for get and set the variables from the private of the TimeSeries class. Secondly, there are the TreeNode class and Tree classes, they work together to build a binary tree that organizes country names (extracted from the hash table) based on computed mean values, each TreeNode contains a fixed-size array for country names and stores range information to support range-based queries. Finally is the Node class which acts as the central manager, containing all used helper function in its private, providing functions to load data from a file into the hash table, list a country’s details, compute range values, build the binary tree (using helper functions like buildSubtree and allSameMean), and perform search (FIND), deletion (REMOVE), and lookup (LOOKUP) operations and ensuring proper memory management.
	
Alternatives and Justification
In Project 4, one alternative approach is to use the linear lookup instead of using hash table. In this project 4, I chose the hash table using double hashing to achieve average-case O(1) lookups, significantly accelerating operations like LOOKUP, INSERT, and REMOVE. Although balanced binary trees were an alternative—providing ordered data and O(log n) search times, they don’t match the constant-time performance of hash tables for direct access. By integrating a hash table for fast lookups while retaining the binary tree for range-based queries (LIMITS), I balance efficiency with the ability to perform ordered operations, meeting the project’s performance and functionality requirements.


Runtime Analysis
In project 4, the hash table uses double hashing to insert and locate countries by their codes. Under typical conditions, collisions are minimal (O(1)), so most lookups find the target in a constant number of probes, resulting in an average-case runtime of O(1). Specifically, the double-hashing approach distributes entries more evenly and reduces clustering, so each search rarely needs to check more than a few slots. However, in the worst-case, if the hash table is nearly full or many countries hash to the same index, the lookup may probe every slot before concluding success or failure, making the runtime O(N), where N is the number of countries.
